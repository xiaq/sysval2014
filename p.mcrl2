sort
  ATPSignal = struct BD | S4 | S6 | S8 | S13;
  ATPMode = struct Normal | Ringing | Ringed | Tolerating | Standby | Dead;

map vm: ATPSignal -> Nat;
    vu, dv: Nat;

eqn vm(S4) = 4; vm(S6) = 6; vm(S8) = 8; vm(S13) = 13;
    vu = 14; dv = 1;

act
  %% External       Internal
  timer1, timeout1,
  timer2, timeout2,
  beacon_stop,      s_beacon_stop, r_beacon_stop, sr_beacon_stop,
  bell,             s_bell, r_bell, sr_bell,
  ebrake,           s_ebrake_1, r_ebrake_1, sr_ebrake_1,
                    s_ebrake_2, r_ebrake_2, sr_ebrake_2,
  reset,            s_reset_1, r_reset_1, sr_reset_1,
                    s_reset_2, r_reset_2, sr_reset_2,
                    s_atp_standby, r_atp_standby, sr_atp_standby,
                    s_atp_wakeup, r_atp_wakeup, sr_atp_wakeup,
                    s_done, r_done, sr_done,
  ertms_signal,
  ertms_standby;
  atp_mode: ATPMode;
  update,           s_update, r_update, sr_update: ATPSignal # Nat # Bool;

proc
  %% Generic ATP
  G(v: Nat, i: Bool) =
    i -> (
      beacon_stop . s_beacon_stop . G(v, false) +
      ertms_signal . s_atp_standby . G(v, true) +
      (v == 0) -> reset . s_reset_1 . s_reset_2 . G(v, true) +
      sum s: ATPSignal .
        sum v: Nat . (v <= 14) ->
          sum b: Bool . update(s, v, b) . ertms_standby .
            ((s == BD) -> (s_atp_standby . G(v, true)) <>
              (s_atp_wakeup . s_update(s, v, b) . G(v, false)))) +
    (r_ebrake_1 + r_ebrake_2) . ebrake . G(v, i) +
    r_bell . bell . G(v, i) +
    r_done . G(v, true);

  %% ATP++
  A(m: ATPMode) =
    (r_reset_1 + r_atp_standby) . ((m == Standby) -> A(m) <> AM(Standby)) +
    r_atp_wakeup . ((m == Standby) -> AM(Normal) <> A(m)) +
    (m == Normal) -> (
      sum s: ATPSignal . sum v: Nat . sum b: Bool . r_update(s, v, b) . (
        (!b && v > vm(s)) -> s_bell . timer1 . s_done . AM(Ringing) <>
        (b && v > vm(s) && v <= vm(s) + dv) ->
          s_bell . s_bell . s_bell . timer2 . s_done . AM(Tolerating) <>
        s_done . A(m))) +
    (m == Tolerating) -> (
      timeout2 . AM(Normal) +
      sum s: ATPSignal . sum v: Nat . sum b: Bool . r_update(s, v, b) . (
        (!b && v > vm(s) + dv) -> s_bell . timer1 . s_done . AM(Ringing) <>
        (v <= vm(s)) -> s_done . AM(Normal) <>
        s_done . A(m))) +
    (m == Ringing) -> (
      timeout1 . A(Ringed) +
      sum s: ATPSignal . sum v: Nat . sum b: Bool . (
        r_update(s, v, b) . s_done . A(m))) +
    (m == Ringed) -> (
      sum s: ATPSignal . sum v: Nat . sum b: Bool . (
        r_update(s, v, b) . (
          (b -> (s_done . AM(Normal)) <> (s_ebrake_1 . s_done .  AM(Dead))))));

  AM(m: ATPMode) = atp_mode(m) . A(m);

  %% Beacon Stopper
  B(d: Bool) =
    r_reset_2 . B(false) +
    d -> (r_beacon_stop . s_done . B(d)) <>
      (r_beacon_stop . s_ebrake_2 . s_done . B(true));

init
  hide(
    {
%      sr_beacon_stop,
%      sr_bell,
%      sr_ebrake_1,
%      sr_ebrake_2,
%      sr_reset_1,
%      sr_reset_2,
%      sr_atp_wakeup,
%      sr_atp_standby,
%      sr_done,
%      sr_update
      s_update
    },
    allow(
      {
        timer1, timeout1,
        timer2, timeout2,
        beacon_stop,
        bell,
        ebrake,
        reset,
        ertms_signal,
        ertms_standby,
        atp_mode,
        update,

        sr_beacon_stop,
        sr_bell,
        sr_ebrake_1,
        sr_ebrake_2,
        sr_reset_1,
        sr_reset_2,
        sr_atp_wakeup,
        sr_atp_standby,
        sr_done,
        sr_update
      },
      comm(
        {
          s_beacon_stop|r_beacon_stop -> sr_beacon_stop,
          s_bell|r_bell -> sr_bell,
          s_ebrake_1|r_ebrake_1 -> sr_ebrake_1,
          s_ebrake_2|r_ebrake_2 -> sr_ebrake_2,
          s_reset_1|r_reset_1 -> sr_reset_1,
          s_reset_2|r_reset_2 -> sr_reset_2,
          s_atp_wakeup|r_atp_wakeup -> sr_atp_wakeup,
          s_atp_standby|r_atp_standby -> sr_atp_standby,
          s_done|r_done -> sr_done,
          s_update|r_update -> sr_update
        },
        G(0, true) || A(Standby) || B(false)
  )));
