<!-- vi: se ft=markdown tw=0 ai: -->

This section presents an annotated version of the complete mCRL2 definition of the process. For an unannotated version, see \autoref{sec:mcrl2}.

## Sorts and maps

We first define two custom sorts, ATPSignal and ATPMode, whose meaning has been covered before. There is also a special “internal” ATP mode, \mode{Ringed}, whose meaning will be explained in \autoref{subsec:proc}.

>>
sort
  ATPSignal = struct BD | S4 | S6 | S8 | S13;
  ATPMode = struct Normal | Ringing | Ringed | Tolerating | Standby | Dead;
<<

We then define the map $vm$ to maps a given ATP signal to the speed limit. The map from BD is intentionally left out.

>>
map vm: ATPSignal -> Nat;
eqn vm(S4) = 4; vm(S6) = 6; vm(S8) = 8; vm(S13) = 13;
<<

We also define two constants $vu$, the maximimal speed allowed, and $dv$, the $\Delta v$ used for tolerating mode, in the form of maps with no parameters.

>>
map vu, dv: Nat;
eqn vu = 15; dv = 1;
<<

## Actions

We now proceed to define the external and internal actions. The external actions have been described above. For each external actions \act{a}, three internal actions \act{s-a} (send), \act{r-a} (receive) and \act{sr-a} (send and receive) are created. This reflects the fact that the ATP++ and Beacon Stopper components don't interact directly with the external world and all messages are routed via G-ATP by internal communication.

There are also three groups of internal-only actions:

1.  \act{atp-standby}: To simplify the logics of mode transitioning, G-ATP rewrites \act{ertms-signal} and \act{update}$(\text{BD}, v, b)$ into an \act{atp-standby} message before passing it to ATP++.

1.  \act{atp-wakeup}: Similarly, when ATP is in \mode{Standby}, G-ATP rewrites any \act{update}$(s, v, b)$ (where $s \neq \text{BD}$) into an \act{atp-wakeup} message. The latter rewriting has the consequence that the first \act{update} message received when ATP is in standby mode only wakes up ATP++ and is then dropped. However, since we assume that \act{update} happens often enough, this will not pose any real problems.

2.  \act{done}: This message is used to synchronize G-ATP with the other two components and will be explained later.

mCRL2 does not support the use of dashes inside identifiers. Underscores are used in the code instead.

>>
act
  %% External       Internal
  timeout1,         s_timeout1, r_timeout1, sr_timeout1,
  timeout2,         s_timeout2, r_timeout2, sr_timeout2,
  beacon_stop,      s_beacon_stop, r_beacon_stop, sr_beacon_stop,
  bell,             s_bell, r_bell, sr_bell,
  ebrake,           s_ebrake, r_ebrake, sr_ebrake,
  reset,            s_reset, r_reset, sr_reset,
                    s_atp_standby, r_atp_standby, sr_atp_standby,
                    s_atp_wakeup, r_atp_wakeup, sr_atp_wakeup,
                    s_done, r_done, sr_done,
  ertms_signal,
  ertms_standby;
  atp_mode,         s_atp_mode, r_atp_mode, sr_atp_mode: ATPMode;
  update,           s_update, r_update, sr_update: ATPSignal # Nat # Bool;
<<

## Processes
\label{subsec:proc}

>>
proc
  G(v: Nat, i: Bool, m: ATPMode) =
    i -> (
      (v == 0) -> reset . s_reset . G(v, false, m) +
      (m != Dead) -> ertms_signal . s_atp_standby . G(v, false, m) +
      (m != Dead && m != Standby) -> beacon_stop . s_beacon_stop . G(v, false, m) +
      (m == Ringing) -> timeout1 . s_timeout1 . G(v, false, m) +
      (m == Tolerating) -> timeout2 . s_timeout2 . G(v, false, m) +
      sum s: ATPSignal .
        sum v: Nat . (v <= vu) ->
          sum b: Bool . update(s, v, b) . ertms_standby .
            ((s == BD) -> (s_atp_standby . G(v, false, m)) <>
              (m == Standby) -> s_atp_wakeup . G(v, false, m) <>
                (s_update(s, v, b) . G(v, false, m)))) +
    sum m: ATPMode . (m != Ringed) -> r_atp_mode(m) . atp_mode(m) . G(v, i, m) +
    r_atp_mode(Ringed) . G(v, i, Ringed) +
    r_ebrake . ebrake . G(v, i, Dead) +
    r_bell . bell . G(v, i, m) +
    r_done . G(v, true, m);

  A(m: ATPMode) =
    (r_reset + r_atp_standby) .  AM(Standby) +
    r_atp_wakeup . ((m == Standby) -> AM(Normal) <> s_done . A(m)) +
    (m == Dead) -> (
      sum s: ATPSignal . sum v: Nat . sum b: Bool .
        r_update(s, v, b) . s_done . A(m)) +
    (m == Normal) -> (
      sum s: ATPSignal . sum v: Nat . sum b: Bool . r_update(s, v, b) . (
        (!b && v > vm(s)) -> s_bell . AM(Ringing) <>
        (b && v > vm(s) && v <= vm(s) + dv) ->
          s_bell . s_bell . s_bell . AM(Tolerating) <>
        s_done . A(m))) +
    (m == Tolerating) -> (
      r_timeout2 . AM(Normal) +
      sum s: ATPSignal . sum v: Nat . sum b: Bool . r_update(s, v, b) . (
        (!b && v > vm(s) + dv) -> s_bell . AM(Ringing) <>
        (v <= vm(s)) -> AM(Normal) <>
        s_done . A(m))) +
    (m == Ringing) -> (
      r_timeout1 . AM(Ringed) +
      sum s: ATPSignal . sum v: Nat . sum b: Bool . (
        r_update(s, v, b) . s_done . A(m))) +
    (m == Ringed) -> (
      sum s: ATPSignal . sum v: Nat . sum b: Bool . (
        r_update(s, v, b) . (
          (b -> AM(Normal) <> (s_ebrake . AM(Dead))))));

  AM(m: ATPMode) = s_atp_mode(m) . s_done . A(m);

  B =
    r_beacon_stop . s_ebrake . s_done . B;
<<

## Init

The init section is pretty conventional. We rewrite all send-receive action pairs into a single send-receive action, disallow the individual send and receive actions, before hiding all internal actions.

>>
init
  hide(
    {
      sr_timeout1,
      sr_timeout2,
      sr_beacon_stop,
      sr_bell,
      sr_ebrake,
      sr_reset,
      sr_atp_wakeup,
      sr_atp_standby,
      sr_done,
      sr_atp_mode,
      sr_update
    },
    allow(
      {
        timeout1,
        timeout2,
        beacon_stop,
        bell,
        ebrake,
        reset,
        ertms_signal,
        ertms_standby,
        atp_mode,
        update,

        sr_timeout1,
        sr_timeout2,
        sr_beacon_stop,
        sr_bell,
        sr_ebrake,
        sr_reset,
        sr_atp_wakeup,
        sr_atp_standby,
        sr_done,
        sr_atp_mode,
        sr_update
      },
      comm(
        {
          s_timeout1|r_timeout1 -> sr_timeout1,
          s_timeout2|r_timeout2 -> sr_timeout2,
          s_beacon_stop|r_beacon_stop -> sr_beacon_stop,
          s_bell|r_bell -> sr_bell,
          s_ebrake|r_ebrake -> sr_ebrake,
          s_reset|r_reset -> sr_reset,
          s_atp_wakeup|r_atp_wakeup -> sr_atp_wakeup,
          s_atp_standby|r_atp_standby -> sr_atp_standby,
          s_done|r_done -> sr_done,
          s_atp_mode|r_atp_mode -> sr_atp_mode,
          s_update|r_update -> sr_update
        },
        G(0, true, Standby) || A(Standby) || B
  )));
<<
<!-- vi: se ft=markdown tw=0 ai: -->
