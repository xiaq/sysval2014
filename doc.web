% Design of an ATP Control System
% XIAO Qi (0925490), XUE Bing (0925548), WANG Fengjun (0925350), ZHANG Hao (0925694)
% \today

\newcommand{\mode}[1]{\textsf{#1}\xspace}
\newcommand{\act}[1]{\textsf{#1}}

\newcommand{\true}{\text{true}\xspace}
\newcommand{\false}{\text{false}\xspace}

# Introduction

In this report, an embedded controller for the Dutch Automatic Train Protection (ATP) system is designed to collaborate with European Railway Traffic Management System (ERTMS). The controller of ATP system consists of three parallel components: Generic ATP (G-ATP), ATP++ and Beacon Stopper. When the train is driving on an ATP-controlled track, there are two kinds of signals that may be detected. One is a pulse shaped electrical signal on the track that carries the information of the speed limit of the current track. The other one is a stop signal generated by the beacons besides the track to stop the train in front of the traffic light. The G-ATP is responsible for detecting these two kinds of signals and communicating with the ERTMS system. The ATP++ implements the ATP speed control strategy and makes decisions about ringing the bell, emergency braking and ERTMS entering standby mode. The Beacon stopper is responsible for stopping the train when the beacon signal is detected. All external actions are routed via the G-ATP component.

There is one particularity in the design of the ATP control strategy. Due to the inertia, especially for the freight train, the brakes of trains have a tendency to be released slowly. As a consequence, the resulting speed is lower than the desired speed, which wastes energy. To solve this problem, a special “tolerating” mode for ATP++ is desired, which allows the driver release the brake before the required speed is reached.

In the following section, the global requirements of the ATP system are introduced. Then, the external actions of the ATP system are defined in the section 3. Next, the global requirements are described in terms of external actions. In section 5, the process of the ATP system is presented using mCRL2.  In section 6,  the modal formulas to verify the designed ATP system are formulated in the model $\mu{}$-calculus.

During the implementation and verification, the 201409.0 release of the mCRL2 toolkit, compiled from source and run on a Linux system, is used. All the functionalities are realised and all the requirements are satisfied. An electronic copy of the code and this report can be found at \url{https://github.com/xiaq/sysval2014}.

# Global Requirements

\label{sec:req}

## Assumptions about the external world

We make the following assumptions about the external world:

1.  The ERTMS system comes into charge whenever it detects the presense of ERTMS signals; it goes out of charge when the ATP system asks it to do so.

1.  When the ERTMS system is in charge, it controls the brake and UI according to the ERTMS signals it receives. When it is not, it polls the current speed and brake status periodically and make this information available to the ATP system. When the ATP system requests it to ring the bell or start emergency braking, it acts accordingly.

1.  The ATP system always polls ATP signals on the antenna, whether it is in charge or not. There is a special signal that indicates ATP should be switched off called “BD” (buiten dienst).

1.  After emergency braking, the driver cannot release the brake until the whole system is reset.

## Notes on ATP modes

We designate five **modes** for the ATP system, namely \mode{Normal}, \mode{Tolerating}, \mode{Ringing}, \mode{Dead} and \mode{Standby}. The modes are crucial for understanding the behavior of the system and it is very tricky to specify the requirements without explicitly considering them. Below is an informal description of the modes:

1.  ATP is in \mode{Standby} mode either when ERTMS is in charge, or the last ATP signal was BD.

1.  ATP is in \mode{Dead} mode after emergency brake occurred and a reset is required.

1.  The other three modes are best explained by illustrating a typical scenerio of over-speeding. As shown in \autoref{fig:over-speeding},

    1.  At time $t=0$, ATP is in \mode{Normal} mode. The train is found to be over-speeding, due to a change in the ATP signal; the maximum speed allowed is $vm$. The brake is off, so ATP rings the bell and enters the \mode{Ringing} mode which always lasts for 3 seconds.

    1.  The \mode{Ringing} mode is special in that *no* speed limits are enfored; instead, ATP waits for the driver to take action. After 3 seconds, ATP finds out that the brake is now on, and comes back to \mode{Normal} mode.

    1.  The speed of train now starts to decrease, until it reaches $vm + \Delta v$, and ATP now ring the bell three times and enters \mode{Tolerating} mode.

    1.  The \mode{Tolerating} mode enfores a modified speed limit of $vm + \Delta v$ instead of $vm$, so the train is no longer considered to be over-speeding and the driver may release the brake. After the speed $vm$ is reached, ATP goes back to \mode{Normal} mode.

\begin{figure}[h]
\begin{center}
    \includegraphics{figures/over-speeding}
    \caption{A typical over-speeding scenerio}
    \label{fig:over-speeding}
\end{center}
\end{figure}

The exact relationships between the modes are specified in the requirements.

## Requirements

1.  When ATP is in \mode{Normal} mode:

    1.  After a change in the brake status or speed:

        1.  If the brake is off, and the speed is higher than the maximum speed allowed according to the signal on the antenna (known as $vm$ afterwards), ATP will request ERTMS to ring the bell and enter \mode{Ringing} mode.

        1.  If the brake is on, and speed is between $vm$ and $vm + \Delta v$, ATP will request ERTMS to ring the bell three times and enter \mode{Tolerating} mode.

    1.  As long as no ERTMS signal is detected, and the speed and brake status do not change, no bell will be ringed and ATP will stay in this mode.

1.  When ATP is in \mode{Tolerating} mode:

    1.  After a change in the brake status or speed:

        1.  If the brake is off, and the speed is higher than $vm + \Delta v$, ATP will request ERTMS to ring the bell and enter \mode{Ringing} mode.

        1.  If the speed is lower than $vm$, ATP will enter \mode{Normal} mode.

    1.  ATP will always enter \mode{Normal} mode after a certain amount of time $\Delta t$.

    1.  As long as no ERTMS signal is detected, and the speed and brake status do not change, ATP will stay in \mode{Tolerating} mode within $\Delta t$.

1.  Three seconds after ATP enters \mode{Ringing} mode:

    1.  If the brake is on, ATP will enter \mode{Normal} mode.

    1.  If the brake is off, ATP will initate an emergency brake.

1.  When ATP is not in \mode{Standby} mode and a beacon-stop signal is detected, it will request ERTMS to start emergency braking.

1.  When ATP is in \mode{Standby} mode, it will not request ERTMS to ring the bell or start emergency braking.

1.  When ATP is in \mode{Standby} mode and it receives signals on the antenna, it will inform ERTMS that ATP will be in charge. If the signal is not BD, it will then enter \mode{Normal} mode.

1.  Whenever ATP receives BD signal on the antenna or is informed that ERTMS signal has been detected, it will enter \mode{Standby} mode.

1.  When the current speed is 0, the whole system may be reset.

1.  When the current speed is not 0, the whole system may not be reset.

1.  The system is free of deadlocks.

# External Actions

\label{sec:act}

Before describing the external actions, we firstly introduce a new action \act{update}$(s: \text{ATPSignal} to simplify our model. 

\act{update}$(s: \text{ATPSignal}, v: \mathbb{N}, b: \mathbb{B})$: ATP is informed of the current ATP signal, the current speed and the current brake status. This action happens periodically (with a period that is small enough) as long as ATP signals are detected on the antenna.

Notes about the \act{update} action:

1.  This action is an abstraction and not very realistic. In the real world, it is more likely that the three types of information come from different channels; namely, there can be an \act{atp-signal}$(s)$ action with which ATP reads a signal from the antenna, a \act{speed}$(v)$ action with which ERTMS informs ATP about the current speed of the train, and a \act{brake-status}$(b)$ action with which ERTMS informs ATP about the current brake status.

    However, packing these three types of information into a single action greatly simplifies the process design and validation. For instance, should there be three actions, we would need to consider their order of arrival when validating the model, which would make the modal formulas unncessarily verbose.

    In the real world where there are likely three actions as described above, this action can be simulated in a straightforward way by adding the following component:

    \begin{verbatim}
proc U(v: Nat, b: Bool) =
  sum v: Nat . speed(v) . U(v, b) + sum b: Bool . brake_status(b) . U(v, b) +
  sum s: ATPSignal . atp_signal(s) . update(s, v, b) . U(v, b);
    \end{verbatim}

    Note, however, that this component is not part of our design.

2.  To limit the size of the state space, the speed parameter $v$ is not the “real” speed but rather divided by 10, rounded up, and capped at 15. Formally, $v = \min(\lceil v_r/10 \rceil, 15)$ where $v_r$ is the real speed. This simplification does not cause any loss of functionality.

\act{atp-mode}$(m: \text{ATPMode})$: ATP announces its new mode. The physical realization can be, for instance, a LED display that shows the name of the mode.

\act{ertms-signal}: ERTMS informs ATP that ERTMS signal is detected (and therefore ERTMS will be in charge).

\act{beacon-stop}: ATP receives a stop signal from a beacon.

\act{bell}: ATP requests ERTMS to ring the bell.

\act{ebrake}: ATP requests ERTMS to start an emergency brake.

\act{ertms-standby}: ATP requests ERTMS to enter standby mode because ATP will be in charge.

\act{timeout1}: ATP has been in \mode{Ringing} mode for 3 seconds.

\act{timeout2}: ATP has been in \mode{Tolerating} mode for $\Delta t$.

\act{reset}: The driver resets the whole system so that the brake can be released.

# Global Requirements (In Terms of External Actions)

In this section, the global requirements from \autoref{sec:req} are given in terms of external actions.

## Assumptions about the external world

We make the following assumptions about the external world:

1.  The ERTMS system comes into charge whenver it detects the presense of ERTMS signals; it goes out of charge when the ATP system initiates an \act{ertms-enter-standby} action.

1.  When the ERTMS system is in charge, it controls the brake and UI according to the ERTMS signals it receives. When it is not, it controls the brake and the bell according to the \act{ebrake} and \act{bell} actions initiated by ATP.

1.  After an \act{ebrake} action, the driver cannot release the brake until a \act{reset} action happens.

## Definition

We introduce the following definition:

1.  The **mode** of the ATP system is defined to be the data in the last $\act{atp-mode}(m)$ action. <!--When no such action has happened, ATP is in \mode{Standby} mode.-->

## Requirements

\label{subsec:req-terms-2}

1.  When ATP is in \mode{Normal} mode:

    1.  When \act{update}$(s, v, b)$, where $s \neq \text{BD}$, happens:

        1.  If $v > vm(s)$ and $b = \false$, ATP initiates \act{bell} and enters \mode{Ringing} mode.

        1.  If $vm(s) < v \le vm(s) + \Delta v$ and $b = \true$, ATP will intiate three \act{bell} actions and enter \mode{Tolerating} mode.

    1.  As long as none of \act{ertms-signal}, \act{update} or \act{reset} happens, no \act{bell} or mode change will happen.

1.  When ATP is in \mode{Tolerating} mode:

    1. When \act{update}$(s, v, b)$, where $s \neq \text{BD}$, happens:

        1.  If $v > vm(s) + \Delta v$ and $b = \false{}$, ATP will initiate \act{bell} and enter \mode{Ringing} mode.

        1.  If $v \le vm(s)$, ATP will enter \mode{Normal} mode.

        <!-- 1.  Otherwise, as long as no \act{timeout2}, \act{ertms-signal} or \act{update} happens, no \act{bell} happens and no mode change happens. -->

    1.  When \act{timeout2} happens, it will enter \mode{Normal} mode.

    1.  As long as none of \act{timeout2}, \act{ertms-signal} or \act{update} happens, no mode change will happen.

1.  When ATP is in \mode{Ringing} mode, and \act{timeout1} and \act{update}$(s, v, b)$, where $s \neq \text{BD}$, happen (with no \act{update}, \act{reset} or \act{ertms-signal} in between):

    1.  If $b = \true{}$, ATP will enter \mode{Normal} mode.

    1.  If $b = \false{}$, ATP will initiate \act{ebrake} and enter \mode{Dead} mode.

1.  When ATP is not in \mode{Standby} mode and \act{beacon-stop} happens, ATP will initiate \act{ebrake}.

1.  When ATP is in \mode{Standby} mode, it will not initiate \act{bell} or \act{ebrake}.

1.  When ATP is in \mode{Standby} mode and \act{update}$(s, v, b)$ happens, it will intiate \act{ertms-standby}. If $s \neq \text{BD}$, it will also subsequently enter \mode{Normal} mode.

1.  Whenever \act{update}$(\text{BD}, v, b)$ or \act{ertms-signal} happens, ATP will enter \mode{Standby} mode.

1.  After an \act{update}$(s, v, b)$ where $s \neq \text{BD}$ and $v = 0$, as long as no \act{update} happens, \act{reset} will always be eventually possible.

1.  After an \act{update}$(s, v, b)$ where $v > 0$, as long as no \act{update} happens, \act{reset} is never allowed.

1.  The system is free of deadlocks.

# Process definitions

This section presents an annotated version of the complete mCRL2 definition of the process. For an unannotated version, see \autoref{sec:mcrl2}.

## Sorts and maps
\label{subsec:sorts-and-maps}

We first define two custom sorts, ATPSignal and ATPMode, whose meanings have been given before. There is also a special “internal” ATP mode, \mode{Ringed}, whose meaning is explained in \autoref{subsec:proc}.

>>
sort
  ATPSignal = struct BD | S4 | S6 | S8 | S13;
  ATPMode = struct Normal | Ringing | Ringed | Tolerating | Standby | Dead;
<<

We now define the map $vm$ to map a given ATP signal to the corresponding speed limit. The map from BD is intentionally left out.

>>
map vm: ATPSignal -> Nat;
eqn vm(S4) = 4; vm(S6) = 6; vm(S8) = 8; vm(S13) = 13;
<<

We also define two constants $vu$, the maximimal speed allowed, and $dv$, the $\Delta v$ used for tolerating mode, in the form of maps with no parameters.

>>
map vu, dv: Nat;
eqn vu = 15; dv = 1;
<<

## Actions

We now proceed to define the external and internal actions. The external actions have been described in \autoref{sec:act}. For each external action \act{a}, three internal actions -- \act{s-a} (send), \act{r-a} (receive) and \act{sr-a} (send and receive) are created. This reflects the fact that the ATP++ and Beacon Stopper components don't interact directly with the external world and all “messages” are routed via G-ATP by internal communication. A “message” is an informal name we give to a group of closely related actions like the just mentioned group of \act{a}, \act{s-a} and \act{r-a} actions.

There are also three groups of internal-only actions:

1.  \act{atp-standby}: To simplify the logics of mode transitioning, G-ATP rewrites \act{ertms-signal} and \act{update}$(\text{BD}, v, b)$ into an \act{atp-standby} message before passing it to ATP++.

1.  \act{atp-wakeup}: Similarly, when ATP is in \mode{Standby} mode, G-ATP rewrites any \act{update}$(s, v, b)$ (where $s \neq \text{BD}$) into an \act{atp-wakeup} message. The latter rewriting has the consequence that an \act{update} message received when ATP is in \mode{Standby} mode only wakes up ATP++ and otherwise has no effect. However, since we assume that \act{update} happens often enough, this will not pose any real problems.

2.  \act{done}: This message is used to synchronize G-ATP with the other two components and is explained in \autoref{subsec:proc}.

An overview of the messages is presented in \autoref{fig:messages}. All internal messages are realised with an \act{s} action on the sending side, an \act{r} action on the receiving side and an \act{sr} action to capture the \act{s}|\act{r} multi-action.

\begin{figure}[h!]
\begin{center}
    \includegraphics[angle=-90,width=\linewidth]{figures/messages}
    \caption{An overview of the conceptual flow of messsages}
    \label{fig:messages}
\end{center}
\end{figure}


mCRL2 does not support the use of dashes inside identifiers. Underscores are used in the code instead.

>>
act
  %% External       Internal
  timeout1,         s_timeout1, r_timeout1, sr_timeout1,
  timeout2,         s_timeout2, r_timeout2, sr_timeout2,
  beacon_stop,      s_beacon_stop, r_beacon_stop, sr_beacon_stop,
  bell,             s_bell, r_bell, sr_bell,
  ebrake,           s_ebrake, r_ebrake, sr_ebrake,
  reset,            s_reset, r_reset, sr_reset,
                    s_atp_standby, r_atp_standby, sr_atp_standby,
                    s_atp_wakeup, r_atp_wakeup, sr_atp_wakeup,
                    s_done, r_done, sr_done,
  ertms_signal,
  ertms_standby;
  atp_mode,         s_atp_mode, r_atp_mode, sr_atp_mode: ATPMode;
  update,           s_update, r_update, sr_update: ATPSignal # Nat # Bool;
<<

## Processes
\label{subsec:proc}

### Generic ATP

The primary role of G-ATP component is routing “messages”. The functionality of only allowing reset when the speed is 0 is also implemented here, which is reflected in the $v$ parameter of the process.

The $i$ (read “idle”) parameter, related to the \act{done} message, is used for synchronizing G-ATP with the other two components. When G-ATP is idle, it is allowed to receive messages from the external world. After routing the message to one of the other two components, it is no longer idle. When not idle it will only respond to internal messages until a \act{done} message is received. This synchronization is crucial for the system to be free of deadlocks. If G-ATP is always allowed to receive external messages, a message can arrive when ATP++ or Beacon Stopper is still busy processing the last message and thus stuck in an intermediate state, likely resulting in a deadlock.

The $m$ parameter keeps track of current ATP mode and is used to decide when certain external actions are allowed.

The \mode{Ringed} mode is internal and thus not announced through an \act{atp-mode} action.

>>
proc
  G(v: Nat, i: Bool, m: ATPMode) =
    i -> (
      (v == 0) -> reset . s_reset . G(v, false, m) +
      (m != Dead) -> ertms_signal . s_atp_standby . G(v, false, m) +
      (m != Dead && m != Standby) -> beacon_stop . s_beacon_stop . G(v, false, m) +
      (m == Ringing) -> timeout1 . s_timeout1 . G(v, false, m) +
      (m == Tolerating) -> timeout2 . s_timeout2 . G(v, false, m) +
      sum s: ATPSignal .
        sum v: Nat . (v <= vu) ->
          sum b: Bool . update(s, v, b) . ertms_standby .
            ((s == BD) -> (s_atp_standby . G(v, false, m)) <>
              (m == Standby) -> s_atp_wakeup . G(v, false, m) <>
                (s_update(s, v, b) . G(v, false, m)))) +
    sum m: ATPMode . (m != Ringed) -> r_atp_mode(m) . atp_mode(m) . G(v, i, m) +
    r_atp_mode(Ringed) . G(v, i, Ringed) +
    r_ebrake . ebrake . G(v, i, Dead) +
    r_bell . bell . G(v, i, m) +
    r_done . G(v, true, m);
<<

### ATP++

The mode of ATP plays a central role in the implementation of ATP++. The \mode{Ringing} mode is implemented internally as two modes, \mode{Ringing} and \mode{Ringed}. This is needed so that intermediate actions between \act{r-timeout1} and \act{update} do not lead to a deadlock.

The auxiliary process AM is defined to capture a recurring series of actions, namely announcing a new mode with \act{s-atp-mode}, concluding the processing procedure with \act{s-done} and then transiting to the mode just announced.

>>
proc
  A(m: ATPMode) =
    (r_reset + r_atp_standby) .  AM(Standby) +
    (m == Standby) -> r_atp_wakeup . AM(Normal) +
    (m == Dead) -> (
      sum s: ATPSignal . sum v: Nat . sum b: Bool .
        r_update(s, v, b) . s_done . A(m)) +
    (m == Normal) -> (
      sum s: ATPSignal . sum v: Nat . sum b: Bool .
        r_update(s, v, b) . (
          (!b && v > vm(s)) -> s_bell . AM(Ringing) <>
          (b && v > vm(s) && v <= vm(s) + dv) ->
            s_bell . s_bell . s_bell . AM(Tolerating) <>
          s_done . A(m))) +
    (m == Tolerating) -> (
      r_timeout2 . AM(Normal) +
      sum s: ATPSignal . sum v: Nat . sum b: Bool .
        r_update(s, v, b) . (
          (!b && v > vm(s) + dv) -> s_bell . AM(Ringing) <>
          (v <= vm(s)) -> AM(Normal) <>
          s_done . A(m))) +
    (m == Ringing) -> (
      r_timeout1 . AM(Ringed) +
      sum s: ATPSignal . sum v: Nat . sum b: Bool .
        r_update(s, v, b) . s_done . A(m)) +
    (m == Ringed) -> (
      sum s: ATPSignal . sum v: Nat . sum b: Bool .
        r_update(s, v, b) . (
          (b -> AM(Normal) <> (s_ebrake . AM(Dead)))));
  AM(m: ATPMode) = s_atp_mode(m) . s_done . A(m);
<<

### Beacon Stopper

The implementation of the beacon stopper is trivial.

>>
proc B = r_beacon_stop . s_ebrake . s_done . B;
<<

## Init

In the `init` section, we choose suitable initial states for the three components, rewrite all \act{s}|\act{r} multiactions into a single \act{sr} action, and allow only external actions and internal \act{sr} actions, before hiding all internal \act{sr} actions.

>>
init
  hide(
    {
      sr_timeout1,
      sr_timeout2,
      sr_beacon_stop,
      sr_bell,
      sr_ebrake,
      sr_reset,
      sr_atp_wakeup,
      sr_atp_standby,
      sr_done,
      sr_atp_mode,
      sr_update
    },
    allow(
      {
        timeout1,
        timeout2,
        beacon_stop,
        bell,
        ebrake,
        reset,
        ertms_signal,
        ertms_standby,
        atp_mode,
        update,
        sr_timeout1,
        sr_timeout2,
        sr_beacon_stop,
        sr_bell,
        sr_ebrake,
        sr_reset,
        sr_atp_wakeup,
        sr_atp_standby,
        sr_done,
        sr_atp_mode,
        sr_update
      },
      comm(
        {
          s_timeout1|r_timeout1 -> sr_timeout1,
          s_timeout2|r_timeout2 -> sr_timeout2,
          s_beacon_stop|r_beacon_stop -> sr_beacon_stop,
          s_bell|r_bell -> sr_bell,
          s_ebrake|r_ebrake -> sr_ebrake,
          s_reset|r_reset -> sr_reset,
          s_atp_wakeup|r_atp_wakeup -> sr_atp_wakeup,
          s_atp_standby|r_atp_standby -> sr_atp_standby,
          s_done|r_done -> sr_done,
          s_atp_mode|r_atp_mode -> sr_atp_mode,
          s_update|r_update -> sr_update
        },
        G(0, true, Standby) || A(Standby) || B
  )));
<<

# Modal formulas

This section presents the modal formulas for the requirements written in the format of MCF. All MCF code is commented. The requirements are presented as independent items below (e.g. requirement 1.1.1 below combines text from item 1, 1.1 and 1.1.1 from \autoref{subsec:req-terms-2}).

In formulating the modal formulas, “\act{a} will happen” is interpreted as “\act{a} will eventually happen” since in virtually all cases there will be some intermediate transitions (often internal actions which are converted into $\tau$). Also, it is assumed that “\act{a} and \act{b} will happen” does not imply an order on the two actions, unless the order is indicated by stating “\act{a} will happen and \act{b} will subsequently happen”.

## Verification Procedure

Assuming that the process definitions and the modal formula are stored in `p.mcrl2` and `r.mcf` respectively, the following commands are used to verify the modal formula:

\begin{verbatim}
mcrl22lps p.mcrl2 p.lps
lps2pbes p.lps -f r.mcf r.pbes
pbes2bool r.pbes
\end{verbatim}

## Formulas

1.1.1 When ATP is in \mode{Normal} mode, \act{update}$(s, v, b)$, where $s \neq \text{BD}$, $v > vm(s)$ and $b = \false$, happens, ATP will initiate \act{bell} and enter \mode{Ringing} mode.

>>1.1.1.mcf
[
% normal mode
true* . atp_mode(Normal) . (forall m: ATPMode. !atp_mode(m))* .
% an update where s!=BD && v>vm(s) && !b happens
exists s: ATPSignal, v: Nat, b: Bool. val(s != BD && vm(s)< v && v<= vu && !b) && update(s, v, b)
]
% eventually bell happens
((mu X. [!bell]X && <true>true) &&
% eventually atp_mode(Ringing) happens
(mu Y. [!atp_mode(Ringing)]Y && <true>true))
<<

1.1.2 When ATP is in \mode{Normal} mode, \act{update}$(s, v, b)$, where $s \neq \text{BD}$, $vm(s) < v \le vm(s) + \Delta v$ and $b = \true$, happens, ATP will intiate three \act{bell} actions and enter \mode{Tolerating} mode.

>>1.1.2.mcf
[
% Normal mode
true* . atp_mode(Normal) . (forall m: ATPMode. !atp_mode(m))* .
% an update where s!=BD && vm(s)< v <= vm(s)+dv happens
exists s: ATPSignal, v: Nat. val( s!= BD && v<vu &&  v<= vm(s)+dv && vm(s)<v) && update(s, v, true)
]
% eventually bell happens three times
(mu X (n:Nat=0). ([bell]X(n+1) && [!bell]X(n) && <true>true || val(n==3)) &&
% eventualy atp_mode(Tolerating) happens
mu Y.([!atp_mode(Tolerating)]Y && <true>true))
<<

1.2 When ATP is in \mode{Normal} mode, as long as none of the \act{ertms-signal}, \act{update} or \act{reset} happen, no \act{bell} or mode change will happen.

>>1.2.mcf
[
% Normal mode
true* . atp_mode(Normal) .
% no more update, ertms signal happens or reset
(!(ertms_signal || exists s: ATPSignal, v: Nat, b: Bool. update(s, v, b) || reset))*
]
% no bell or atp_mode is possible
[((exists m: ATPMode. (atp_mode(m))) || bell)]false
<<

2.1.1 When ATP is in \mode{Tolerating} mode and \act{update}$(s, v, b)$, where $s \neq \text{BD}$, $v > vm(s) + \Delta v$ and $b = \false{}$, happens, ATP will initiate \act{bell} and enter the \mode{Ringing} mode.

>>2.1.1.mcf
[
% tolerating mode
true* . atp_mode(Tolerating) .  (forall m: ATPMode. !atp_mode(m))* .
% an update where s!=BD && v>vm(s)+dv && !b happens
exists s: ATPSignal, v: Nat, b: Bool. val(s != BD && v <= vu && v>vm(s)+dv && !b) && update(s, v, b)
]
% eventually bell happens
((mu X. [!bell]X && <true>true) &&
% eventually atp_mode(Ringing) happens
(mu X. [!atp_mode(Ringing)]X && <true>true))
<<

2.1.2 When ATP is in \mode{Tolerating} mode and \act{update}$(s, v, b)$, where $s \neq \text{BD}$ and $v \le vm(s)$, happens, ATP will enter \mode{Normal} mode.

>>2.1.2.mcf
[
% tolerating mode
true* . atp_mode(Tolerating) .  (forall m: ATPMode. !atp_mode(m))* .
% an update where s!=BD && v <= vm(s) happens
exists s: ATPSignal, v: Nat, b: Bool. val(s != BD && v <= vm(s)) && update(s, v, b)
]
% eventually atp_mode(Normal) happens
mu X.([!atp_mode(Normal)]X && <true>true)
<<

2.2 When ATP is in \mode{Tolerating} mode and \act{timeout2} happens, it will enter \mode{Normal} mode.

>>2.2.mcf
[
% tolerating mode
true* . atp_mode(Tolerating) . (forall m: ATPMode . !atp_mode(m))* .
% timeout2 happens
timeout2
]
% eventually atp_mode(Normal) happens
mu X. ([!atp_mode(Normal)]X && <true>true)
<<

2.3 When ATP is in \mode{Tolerating} mode, as long as none of \act{timeout2}, \act{ertms-signal} or \act{update} happens, no mode change will happen.

>>2.3.mcf
[
% tolerating mode
true* . atp_mode(Tolerating) .
% no timeout2, ertms_signal, update happens
(!(timeout2 || ertms_signal || exists s: ATPSignal, v: Nat, b: Bool. update(s, v, b)))*
]
% no atp_mode is possible
[exists m: ATPMode. atp_mode(m)] false
<<

3.1 When ATP is in \mode{Ringing} mode, and \act{timeout1} and \act{update}$(s, v, b)$, where $s \neq \text{BD}$ and $b = \true{}$, happen (with no \act{update}, \act{reset} or \act{ertms-signal} in between), ATP will enter \mode{Normal} mode.

>>3.1.mcf
[
% Ringing mode
true* . atp_mode(Ringing) . ((forall m: ATPMode. !atp_mode(m)) && !timeout1)* . 
% timeout1 and update(s,v,b) happen, where s!=BD && b==true, with no update,
% reset or ertms_signal in between
timeout1 .
((forall s: ATPSignal, v: Nat, b: Bool . !update(s, v, b)) && !reset && !ertms_signal)* .
exists s: ATPSignal, v: Nat, b: Bool. val(v<=vu && s!=BD) && update(s,v,true)
]
% eventually atp_mode(Normal) happens
mu X. ([!atp_mode(Normal)] X && <true>true)
<<

3.2 When ATP is in \mode{Ringing} mode, and \act{timeout1} and \act{update}$(s, v, b)$, where $s \neq \text{BD}$ and $b = \false{}$, happen (with no \act{update}, \act{reset} or \act{ertms-signal} in between), ATP will initiate \act{ebrake} and enter \mode{Dead} mode.

>>3.2.mcf
[
% Ringing mode
true* . atp_mode(Ringing) . ((forall m: ATPMode. !atp_mode(m)) && !timeout1)* . 
% timeout1 and update(s,v,b) happen, where s!=BD && b==false, with no update,
% reset or ertms_signal in between
timeout1 .
((forall s: ATPSignal, v: Nat, b: Bool . !update(s, v, b)) && !reset && !ertms_signal)* .
exists s: ATPSignal, v: Nat, b: Bool. val(v<=vu && s!=BD) && update(s,v,false)
]
% eventually brake takes place and ATP enters Dead mode
mu X.([!ebrake]X && <true>true && (mu Y. [!atp_mode(Dead)]Y && <true>true))
<<

4 When ATP is not in \mode{Standby} mode and \act{beacon-stop} happens, ATP will initiate \act{ebrake}.

>>4.mcf
[
% ATP is not in Standby mode
true*.(exists m:ATPMode.val(m!=Standby) && atp_mode(m)).
% ATP does not enter Standby mode
(!atp_mode(Standby))*.
% beacon stop happens
beacon_stop
]
% eventually ebrake happens
mu X.(<true>true && [!ebrake]X)
<<

5 When ATP is in \mode{Standby} mode, it will not initiate \act{bell} or \act{ebrake}.

>>5.mcf
[
% ATP is in standby mode
true* . atp_mode(Standby).
% no transition into another mode
(!(exists m:ATPMode.(val(m!=Standby)&&atp_mode(m))))*
]
% will not initiate bell or ebrake
[bell+ebrake]false
<<

6 When ATP is in \mode{Standby} mode and \act{update}$(s, v, b)$ happens, it will initiate \act{ertms-standby}. If $s \neq \text{BD}$, it will also subsequently enter \mode{Normal} mode.

>>6.mcf
forall s:ATPSignal,v: Nat,b: Bool.val(v<=vu)=>(
[
% ATP is in standby mode
true*.atp_mode(Standby).
% ATP does not enter into another mode
(!(exists m:ATPMode.(val(m!=Standby)&&atp_mode(m))))*.
% update happens
update(s,v,b)
]
% eventually ertms_standby happens
mu X.([!ertms_standby]X && <true>true && [ertms_standby]
% if S!=BD ATP eventually enters into Normal mode
(val(s!=BD)=>(mu Y.([!atp_mode(Normal)]Y && <true>true)))))
<<

7 Whenever \act{update}$(\text{BD}, v, b)$ or \act{ertms-signal} happens, ATP will enter \mode{Standby} mode.

>>7.mcf
% update(BD,s,v) or ertms_signal happens
[true* . (ertms_signal||exists v: Nat,b: Bool.val(v<=vu)&&update(BD,v,b))]
% eventually enters into Standby mode
mu X.([!atp_mode(Standby)]X && <true>true)
<<

8 After an \act{update}$(s, v, b)$ where $s \neq \text{BD}$ and $v = 0$, as long as no \act{update} happens, \act{reset} will always be eventually possible.

>>8.mcf
[
true* .
% update(s, 0, b) happens
exists s: ATPSignal, b: Bool . val(s!=BD) && update(s, 0, b)
]
% as long as no update happens, reset is eventually possible
mu X . (([!(exists s: ATPSignal, v: Nat, b: Bool . update(s, v, b))] X || <reset> true))
<<

9 After an \act{update}$(s, v, b)$ where $v > 0$, as long as no \act{update} happens, \act{reset} is never possible.

>>9.mcf
[
% an update where v >= 1 happens
true* . (exists s: ATPSignal, v: Nat, b: Bool . val(v >= 1 && v <= vu) && update(s, v, b)) .
% no more updates
(forall s: ATPSignal, v: Nat, b: Bool . !update(s, v, b))*
]
% reset is not allowed
[ reset ] false
<<

10 The system is free of deadlocks.

>>10.mcf
[ true* ] < true > true
<<

# Appendix: Unannotated mCRL2 source

In this section we present the complete, unannotated definition of the process in mCRL2.

\label{sec:mcrl2}

\input{p.mcrl2.tex}

<!-- vi: se ft=markdown tw=0 ai: -->
