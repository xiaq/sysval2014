\newcommand{\mode}[1]{\textsf{#1}\xspace}
\newcommand{\act}[1]{\textsf{#1}\xspace}

\newcommand{\true}{\text{true}\xspace}
\newcommand{\false}{\text{false}\xspace}

# Introduction

In this report, an embedded controller of Dutch Automatic Train Protection (ATP) system is designed to collaborate with European Railway Traffic Management System (ERTMS). The controller of ATP system consists of three parallel components: Generic ATP (G-ATP), ATP++ and Beacon Stopper. When the train is driving on an ATP-controlled track, there are two kinds of signal that may be detected. One is pulse shaped electrical signal on the track that carries the information of the speed limit of the current track. The other one is stop signal generated by the beacons besides the track to stop the train in front of the traffic light. The G-ATP is responsible for detecting these two kinds of signals and communicating with ERTMS. The ATP++ implements ATP speed control strategy and makes decisions about ringing bell, emergency braking and ERTMS entering standby mode. The Beacon stopper is responsible for stopping the train when the beacon signal is detected. All external actions are routed via the G-ATP component.

There is one particularity in the design of ATP control strategy. Due to the inertia, especially for the freight train, the brakes of trains have a tendency to be released slowly. As a consequence, the resulted speed is lower than the desired speed, which wastes energy. To solve this problem, a special tolerating mode for ATP++ is desired, which allows driver release brake before the required speed and reach the requirement eventually.

In the following section, the global requirements of the ATP system is introduced. Then, the external actions of the ATP system are defined in the section 3. Next, the Global requirements are described in terms of external actions. In section 5, the process of the ATP system is presented by using mCRL2.  In section 6,  the model formula to verify the designed ATP system is formulated in $\mu{}$-calculus.

During the implementation and verification, the 201409.0 release of the mCRL2 toolkit used. All the functionalities are realised and all the requirements are satisfied.

# Global Requirements

## Assumptions about the external world

1.  The ERTMS system comes into charge whenever it detects the presense of ERTMS signals; it goes out of charge when the ATP system asks it to do so.

1.  When the ERTMS system is in charge, it controls the brake and UI according to the ERTMS signals it receives. When it is not, it polls the current speed and brake status periodically and make this information available to the ATP system. When the ATP system requests it to ring the bell or start emergency braking, it acts accordingly.

1.  The APT system always polls ATP signals on the antenna, whether it is in charge or not. There is a special signal that indicates ATP should be switched off called “BD” (buiten dienst).

1.  After emergency braking, the driver cannot release the brake until the whole system is reset.

## Note on ATP modes

We designate five **modes** for the ATP system, namely \mode{Normal}, \mode{Tolerating}, \mode{Ringing}, \mode{Dead} and \mode{Standby}. Ideally, knowledge about the different modes should be internal details. However, we find it very tricky to specify the requirements without explicitly considering modes. Below is an informal description of the different modes:

1.  ATP is in \mode{Standby} mode either when ERTMS is in charge, or the last ATP signal was BD.

1.  ATP is in \mode{Dead} mode after emergency brake and a reset is required.

1.  The other three modes are best explained by illustrating a typical scenerio of over-speeding. As shown in \autoref{fig:over-speeding},

    1.  At time $t=0$, ATP is in \mode{Normal} mode. The train is found to be over-speeding, due to a change in the ATP signal; the maximum speed allowed is $vm$. The brake is off ATP rings the bell and enters the \mode{Ringing} mode which always lasts for 3 seconds.

    1.  The \mode{Ringing} mode is special in that *no* speed limits are enfored; instead, ATP waits for the driver to take action. After 3 seconds, ATP finds out that the brake is now on, and comes back to \mode{Normal} mode.

    1.  The speed of train now starts to decrease, until it reaches $vm + \Delta v$, and ATP now ring the bell three times and enters \mode{Tolerating} mode.

    1.  The \mode{Tolerating} mode will enfore a modified speed limit of $vm + \Delta v$ instead of $vm$, so the current speed is now considered over-speeding and the driver may release the brake. After the speed $vm$ is reached, ATP goes back to \mode{Normal} mode.

\begin{figure}[h]
\begin{center}
    \includegraphics{figures/over-speeding}
    \caption{A typical over-speeding scenerio}
    \label{fig:over-speeding}
\end{center}
\end{figure}

The exact relationships between the modes are specified in the requirements.

## Requirements

<!-- TODO 2: Match the structure of the "Global Requirements (In Terms of External Actions)" section -->

1.  When ATP is in \mode{Normal} mode:

    1.  If the brake is off, and the current speed is higher than the maximum speed allowed on the antenna (known as $vm$ afterwards), ATP requests ERTMS to ring the bell and enters \mode{Ringing} mode.

    1.  If the brake is on, and current speed is between $vm$ and $vm + \Delta v$, ATP requests ERTMS to ring the bell three times and enter \mode{Tolerating} mode.

    1.  Otherwise, no bell is ringed and ATP stays in this mode.

1.  When ATP is in \mode{Tolerating} mode:

    1.  If the brake is off, and the current speed is higher than $vm + \Delta v$, ATP requests ERTMS to ring the bell and enters \mode{Ringing} mode.

    1.  If the current speed is lower than $vm$, ATP enters \mode{Normal} mode.

    1.  ATP always enters \mode{Normal} after a specified amount of time, $\Delta t$.

    1.  If the current speed is higher than $vm$, ATP will stay in \mode{Tolerating} mode within $\Delta t$.

1.  Three seconds after ATP enters \mode{Ringing} mode:

    1.  If the brake is on, ATP enters \mode{Normal} mode.

    1.  If the brake is off, ATP initates an emergency brake.

1.  When ATP is not in \mode{Standby} mode and a beacon-stop signal is detected, it will request ERTMS to start emergency braking.

1.  When ATP is in \mode{Standby} mode, it will not request ERTMS to ring the bell or start emergency braking.

1.  When ATP is in \mode{Standby} mode, and it receives signals on the antenna it will inform ERTMS that ATP will be in charge. If the signal is not BD, it will then enter \mode{Normal} mode.

1.  Whenever ATP receives BD signal on the antenna, it enters \mode{Standby} mode.

1.  When the current speed is 0, the whole system may be reset.

1.  When the current speed is not 0, the whole system may not be reset.

1.  The system is free of deadlocks.

# External Actions

<!-- TODO 3: Document the rationale behind a single "update" action instead of three actions; document the v parameter (divided by 10 and capped at 15) -->

\act{update}$(s, v, b)$: ATP is informed of the current ATP signal, the current speed and the current brake status. This action always happens when an ATP signal is received on the antenna.

\act{ertms-signal}: ERTMS informs ATP that ERTMS signal is detected and therefore ERTMS will be in charge.

\act{beacon-stop}: ATP receives a stop signal from a beacon.

\act{bell}: ATP requests ERTMS to ring the bell.

\act{ebrake}: ATP requests ERTMS to start an emergency brake.

\act{ertms-standby}: ATP requests ERTMS to enter standby mode because ATP will be in charge.

\act{timer1}: ATP starts timer 1 which will go off in 3 seconds.

\act{timeout1}: timer1 goes off.

\act{timer2}: ATP starts timer 2 which will go off in 3 minutes.

\act{timeout2}: timer2 goes off.

\act{reset}: The driver resets the whole system so that the brake can be released.

\act{atp-mode}$(m)$: ATP announces its new mode.

# Global Requirements (In Terms of External Actions)

## Assumptions about the external world

1.  The ERTMS system comes into charge whenver it detects the presense of ERTMS signals; it goes out of charge when the ATP system initiates an \act{ertms-enter-standby} action.

1.  When the ERTMS system is in charge, it controls the brake and UI according to the ERTMS signals it receives. When it is not, it controls the brake and the bell according to the \act{ebrake} and \act{bell} actions initiated by ATP.

1.  The action \act{update} happens periodically, if ATP signal is received on the antenna. It also informs the ATP system of the current speed and brake status. This action happens

1.  After an \act{ebrake} action, the driver cannot release the brake until a \act{reset} action happens.

## Definition

1.  The **mode** of the ATP system is defined to be the data in the last $\act{atp-mode}(m)$ action. When no such action has happened, ATP is in \mode{Standby} mode.

## Requirements

1.  When ATP is in \mode{Normal} mode:

    1.  When \act{update}$(s, v, b)$, where $s \neq \text{BD}$, happens:

        1.  If $v > vm(s)$ and $b = \false$, ATP initiates \act{bell} and enters \mode{Ringing} mode.

        1.  If $vm(s) < v < vm(s) + \Delta v$, ATP intiates three \act{bell} actions and enter \mode{Tolerating} mode.

    1.  As long as neither of \act{ertms-signal} or \act{update} happens, no \act{bell} happens and no mode change happens.

1.  When ATP is in \mode{Tolerating} mode:

    1. When \act{update}$(s, v, b)$, where $s \neq \text{BD}$, happens:

        1.  If $v > vm(s) + \Delta v$ and $b = \false{}$, ATP initiates \act{bell} and enters \mode{Ringing} mode.

        1.  If $v \le vm(s)$, ATP enters \mode{Normal} mode.

        <!-- 1.  Otherwise, as long as no \act{timeout2}, \act{ertms-signal} or \act{update} happens, no \act{bell} happens and no mode change happens. -->

    1.  When \act{timeout2} happens, it enters \mode{Normal} mode.

    1.  As long as none of \act{timeout2}, \act{ertms-signal} or \act{update} happens, no mode change happens.

1.  When ATP is in \mode{Ringing} mode, and \act{timeout1} and \act{update}$(s, v, b)$, where $s \neq \text{BD}$, happen:

    1.  If $b = \true{}$, ATP enters \mode{Normal} mode.

    1.  If $b = \false{}$, ATP initiates \act{ebrake} and enters \mode{Dead} mode.

1.  When ATP is not in \mode{Standby} mode and \act{beacon-stop} happens, ATP will initiate \act{ebrake}.

1.  When ATP is in \mode{Standby} mode, it will not initiate \act{bell} or \act{ebrake}.

1.  When ATP is in \mode{Standby} mode and \act{update}$(s, v, b)$ happens, it intiates \act{ertms-standby}. If $s \neq \text{BD}$, it then enters \mode{Normal} mode.

1.  Whenever \act{update}$(\text{BD}, v, b)$ happens, ATP enters \mode{Standby} mode.

1.  After an \act{update}$(s, v, b)$ where $s \neq \text{BD}$ and $v = 0$, as long as no \act{update} happens, \act{reset} will always be eventually possible.

1.  After an \act{update}$(s, v, b)$ where $v > 0$, as long as no \act{update} happens, \act{reset} is never allowed.

1.  The system is free of deadlocks.

# Process definitions

This section presents an annotated version of the complete mCRL2 definition of the process. For an unannotated version, see \autoref{sec:mcrl2}.

## Sorts and maps

We first define two custom sorts, ATPSignal and ATPMode, whose meaning has been covered before. There is also a special “internal” ATP mode, \mode{Ringed}, whose meaning will be explained in \autoref{subsec:proc}.

>>
sort
  ATPSignal = struct BD | S4 | S6 | S8 | S13;
  ATPMode = struct Normal | Ringing | Ringed | Tolerating | Standby | Dead;
<<

We then define the map $vm$ to maps a given ATP signal to the speed limit. The map from BD is intentionally left out.

>>
map vm: ATPSignal -> Nat;
eqn vm(S4) = 4; vm(S6) = 6; vm(S8) = 8; vm(S13) = 13;
<<

We also define two constants $vu$, the maximimal speed allowed, and $dv$, the $\Delta v$ used for tolerating mode, in the form of maps with no parameters.

>>
map vu, dv: Nat;
eqn vu = 15; dv = 1;
<<

## Actions

We now proceed to define the external and internal actions. The external actions have been described above. For each external actions \act{a}, three internal actions \act{s-a} (send), \act{r-a} (receive) and \act{sr-a} (send and receive) are created. This reflects the fact that the ATP++ and Beacon Stopper components don't interact directly with the external world and all messages are routed via G-ATP by internal communication.

There are also three groups of internal-only actions:

1.  \act{atp-standby}: To simplify the logics of mode transitioning, G-ATP rewrites \act{ertms-signal} and \act{update}$(\text{BD}, v, b)$ into an \act{atp-standby} message before passing it to ATP++.

1.  \act{atp-wakeup}: Similarly, when ATP is in \mode{Standby}, G-ATP rewrites any \act{update}$(s, v, b)$ (where $s \neq \text{BD}$) into an \act{atp-wakeup} message. The latter rewriting has the consequence that the first \act{update} message received when ATP is in standby mode only wakes up ATP++ and is then dropped. However, since we assume that \act{update} happens often enough, this will not pose any real problems.

2.  \act{done}: This message is used to synchronize G-ATP with the other two components and will be explained later.

mCRL2 does not support the use of dashes inside identifiers. Underscores are used in the code instead.

>>
act
  %% External       Internal
  timeout1,         s_timeout1, r_timeout1, sr_timeout1,
  timeout2,         s_timeout2, r_timeout2, sr_timeout2,
  beacon_stop,      s_beacon_stop, r_beacon_stop, sr_beacon_stop,
  bell,             s_bell, r_bell, sr_bell,
  ebrake,           s_ebrake, r_ebrake, sr_ebrake,
  reset,            s_reset, r_reset, sr_reset,
                    s_atp_standby, r_atp_standby, sr_atp_standby,
                    s_atp_wakeup, r_atp_wakeup, sr_atp_wakeup,
                    s_done, r_done, sr_done,
  ertms_signal,
  ertms_standby;
  atp_mode,         s_atp_mode, r_atp_mode, sr_atp_mode: ATPMode;
  update,           s_update, r_update, sr_update: ATPSignal # Nat # Bool;
<<

## Processes
\label{subsec:proc}

The G-ATP component

>>
proc
  G(v: Nat, i: Bool, m: ATPMode) =
    i -> (
      (v == 0) -> reset . s_reset . G(v, false, m) +
      (m != Dead) -> ertms_signal . s_atp_standby . G(v, false, m) +
      (m != Dead && m != Standby) -> beacon_stop . s_beacon_stop . G(v, false, m) +
      (m == Ringing) -> timeout1 . s_timeout1 . G(v, false, m) +
      (m == Tolerating) -> timeout2 . s_timeout2 . G(v, false, m) +
      sum s: ATPSignal .
        sum v: Nat . (v <= vu) ->
          sum b: Bool . update(s, v, b) . ertms_standby .
            ((s == BD) -> (s_atp_standby . G(v, false, m)) <>
              (m == Standby) -> s_atp_wakeup . G(v, false, m) <>
                (s_update(s, v, b) . G(v, false, m)))) +
    sum m: ATPMode . (m != Ringed) -> r_atp_mode(m) . atp_mode(m) . G(v, i, m) +
    r_atp_mode(Ringed) . G(v, i, Ringed) +
    r_ebrake . ebrake . G(v, i, Dead) +
    r_bell . bell . G(v, i, m) +
    r_done . G(v, true, m);
<<

>>
proc
  A(m: ATPMode) =
    (r_reset + r_atp_standby) .  AM(Standby) +
    (m == Standby) -> r_atp_wakeup . AM(Normal) +
    (m == Dead) -> (
      sum s: ATPSignal . sum v: Nat . sum b: Bool .
        r_update(s, v, b) . s_done . A(m)) +
    (m == Normal) -> (
      sum s: ATPSignal . sum v: Nat . sum b: Bool . r_update(s, v, b) . (
        (!b && v > vm(s)) -> s_bell . AM(Ringing) <>
        (b && v > vm(s) && v <= vm(s) + dv) ->
          s_bell . s_bell . s_bell . AM(Tolerating) <>
        s_done . A(m))) +
    (m == Tolerating) -> (
      r_timeout2 . AM(Normal) +
      sum s: ATPSignal . sum v: Nat . sum b: Bool . r_update(s, v, b) . (
        (!b && v > vm(s) + dv) -> s_bell . AM(Ringing) <>
        (v <= vm(s)) -> AM(Normal) <>
        s_done . A(m))) +
    (m == Ringing) -> (
      r_timeout1 . AM(Ringed) +
      sum s: ATPSignal . sum v: Nat . sum b: Bool . (
        r_update(s, v, b) . s_done . A(m))) +
    (m == Ringed) -> (
      sum s: ATPSignal . sum v: Nat . sum b: Bool . (
        r_update(s, v, b) . (
          (b -> AM(Normal) <> (s_ebrake . AM(Dead))))));
  AM(m: ATPMode) = s_atp_mode(m) . s_done . A(m);
<<

>>
proc
  B =
    r_beacon_stop . s_ebrake . s_done . B;
<<

## Init

The init section is pretty conventional. We rewrite all send-receive action pairs into a single send-receive action, disallow the individual send and receive actions, before hiding all internal actions.

>>
init
  hide(
    {
      sr_timeout1,
      sr_timeout2,
      sr_beacon_stop,
      sr_bell,
      sr_ebrake,
      sr_reset,
      sr_atp_wakeup,
      sr_atp_standby,
      sr_done,
      sr_atp_mode,
      sr_update
    },
    allow(
      {
        timeout1,
        timeout2,
        beacon_stop,
        bell,
        ebrake,
        reset,
        ertms_signal,
        ertms_standby,
        atp_mode,
        update,

        sr_timeout1,
        sr_timeout2,
        sr_beacon_stop,
        sr_bell,
        sr_ebrake,
        sr_reset,
        sr_atp_wakeup,
        sr_atp_standby,
        sr_done,
        sr_atp_mode,
        sr_update
      },
      comm(
        {
          s_timeout1|r_timeout1 -> sr_timeout1,
          s_timeout2|r_timeout2 -> sr_timeout2,
          s_beacon_stop|r_beacon_stop -> sr_beacon_stop,
          s_bell|r_bell -> sr_bell,
          s_ebrake|r_ebrake -> sr_ebrake,
          s_reset|r_reset -> sr_reset,
          s_atp_wakeup|r_atp_wakeup -> sr_atp_wakeup,
          s_atp_standby|r_atp_standby -> sr_atp_standby,
          s_done|r_done -> sr_done,
          s_atp_mode|r_atp_mode -> sr_atp_mode,
          s_update|r_update -> sr_update
        },
        G(0, true, Standby) || A(Standby) || B
  )));
<<

<!-- TODO 5: Include and document all MCF sources -->

# Appendix: Unannotated mCRL2 source

\label{sec:mcrl2}

\input{p.mcrl2.tex}

<!-- vi: se ft=markdown tw=0 ai: -->
